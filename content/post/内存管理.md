---
title: "内存管理"
date: 2020-04-09T23:28:47+08:00
lastmod: 2020-04-09T23:28:47+08:00
draft: true
tags: []
categories: []
mathjax: false
---

本文主要记录内存管理相关的一些笔记。  
<!--more-->

# 布局
## 系统
### 32位  
2~3G。  

### 64位  
虚拟内存大小，物理内存+swap。  

## 进程
text, bss, data  
heap, stack  

# 分配器
- jemalloc  
  https://github.com/jemalloc/jemalloc
- tcmalloc  
  https://github.com/google/tcmalloc

# 回收策略
- 手动  
  通过malloc,free和new,delete等手动申请、释放内存。  
  优点是速度快，缺点是容易遗漏。  
- GC自动回收  
  由GC(Garbage Collector)自动扫描回收不再使用的内存。  
  优点是不需要程序员介入，缺点是有性能开销，不适合实时的场合(有STW停顿扫描时间)。
- 其他  
  引用计数回收(需要避免循环引用)、Rust检查所有权和生命周期由编译器管理内存。  

# 常见问题
## 泄露与OOM
当申请内存大小多于剩余可用内存时就会发生OOM(out of memory)。  

有可能是特殊请求导致申请过大的内存，一般需要抓包复现。  
另外的可能就是内存泄露，特别是运行时间比较长才出现的情况。可以参考[内存泄露定位](/post/内存泄露定位/) 的说明。  

## 溢出
- AddressSanitizer  
  可以通过 [AddressSanitizer](https://github.com/google/sanitizers/wiki/AddressSanitizer) 进行定位，需要4.8以上GCC或3.1以上LLVM。  
  AddressSanitizer支持各种内存问题的检查(包括下面提到的各种问题)。  
  在编译器支持的情况下优先使用AddressSanitizer协助定位。  
  ```sh
  加上编译选项 -fsanitize=address -fno-omit-frame-pointer
  ```
- GDB  
  如果编译器版本较低，也不方便升级的话可以通过GDB+watch命令定位。  
  ```sh
  # 局部变量 (先断点运行到所在函数)
  watch var
  
  # 全局变量
  watch *((char *)&g_var)
  ```

### 栈溢出
一般就是栈上的局部数组发生越界访问。  

### 堆溢出
一般就是堆上内存的越界访问。  

### 全局数据溢出
一般就是data/bss段的全局(数组)变量的越界访问。  

## 访问非法地址
一般是解引用了空指针或者野指针，触发SIGSEGV信号。  
通过coredump文件或者注册SIGSEGV信号处理函数进行回溯定位。  

