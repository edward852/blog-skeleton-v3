---
title: "常用数据结构"
date: 2020-03-31T15:42:12+08:00
lastmod: 2020-03-31T15:42:12+08:00
draft: false
tags: ["array", "stack", "queue", "list", "hash", "tree", "heap"]
categories: ["data-structure"]
mathjax: false
---

本文主要记录常用的一些数据结构。  
<!--more-->

# 源码实现
可以参考开源项目的代码，比如说linux和redis等。  

# 数组
## 静态数组
大小固定的数组，适合存储固定大小的数据。  

## 动态数组
可动态调整大小的数组，一般的实现在扩容时有复制旧数据的性能开销。  
可以考虑使用deque替代(内部是多个数据块拼接)。  

# 栈
适合存储后进先出的数据。  
可以用来模拟递归调用，避免栈溢出。  
在深度优先搜索中也比较常用。  

# 队列
## FIFO队列
适合存储先进先出的数据。  
在广度优先搜索中也比较常用。  

## 优先级队列
按优先级出队，适合存储需要按优先级处理的数据。  
一般是通过大堆实现。  

## 双端队列deque
前端、后端皆可快速插入、删除的队列。  
适合撤消历史(环形缓冲可能更适合)或者work-stealing场景使用[^1] 。  

# 链表
C语言中通用链表一般是通过`void *`或者像linux那样内嵌节点实现。  
C++一般是通过泛型，具体参考STL容器即可。  
另外可以使用双重指针简化插入、删除操作，快慢指针检查是否循环等。  

## 双向链表
可正向、反向遍历的链表，已经找到节点的情况下可快速删除、插入节点。  

## 单向链表
只能正向遍历的链表，比双向链表节省空间。  

## 跳跃表skiplist
随机化数据结构。多层链表，加快查找、插入、删除操作(复杂度为logN)。  
相比平衡树，在内存占用、范围查找、实现难易等方面有优势。  

# 哈希表
在冲突率不高时，查找、插入、删除可在常量时间完成。  
哈希表的快速是靠空间换时间，会多耗一些内存。  
在冲突率高时，需要扩容并重新哈希，建议采用类似redis那样的渐进式rehash。  

## 多阶哈希表
通过多次哈希解决冲突、提高空间利用率的哈希表，可以通过一维数组模拟(可放入共享内存)。  

## Bloom Filter
快速判断元素是否在集合中。  
比如说垃圾邮件过滤的场景或者辅助加速查询。  
优点是速度快、省空间，缺点是有小概率误报、不能删除元素。  

## Cuckoo Filter
类似Bloom Filter，支持删除元素(不漏报)。  
- http://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pdf  

## CQF
- https://github.com/splatlab/cqf  
- https://research.vmware.com/files/attachments/0/0/0/0/0/2/9/paper.pdf  

# 树

## 大小堆
适合存储1~N个极值的数据。  
适合TopN类需求或者优先级队列、定时器的场景。  
虽然大小堆是树结构，但是底层存储使用动态数组即可。  

## 红黑树
平衡树变种，简化插入、删除后调整树的操作。  
在红黑树的基础上可以实现set、map等容器。  
具体可以参考linux的实现版本。  

## trie树
前缀树，适合大量字符串检索、去重、前缀匹配、统计等场景。  

## 赢家树,输家树
外部排序用到的数据结构，类似小堆可快速取出最小元素(速度快一点)。  

## B树系列
todo

## 哈夫曼编码树

# 位图bitmap
按位存储的数据结构，节省空间，适合存储类似标志位的数据。  

# 环形缓冲
环形缓冲(ringbuffer)是单读单写可无锁的数据结构。  
通过多个ringbuffer可以实现多对一的无锁通信。  

# 双缓冲
空间换取并发安全的数据结构。  
可以用来定时更新配置。  
具体参考 [DoubleBuffer](/post/doublebuffer/) 的说明。  

# 图
todo

# 参考链接
- [tommyds](https://github.com/amadvance/tommyds)

[^1]: https://en.wikipedia.org/wiki/Double-ended_queue#Applications
